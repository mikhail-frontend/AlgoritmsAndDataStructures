const arrayExample = [1, 3, '22', true];

arrayExample.push(1) // здесь сложность алгоритма  O(1) (констатная), посколько мы изменяем только одно последнее значение массива,
// не меняя его индексы. Т.е. массив можно условно разложить на {index: 0, value: 1}, {index: 1, value: 3} и т.д.
// добавление элемента в массив не меняет индексы других элементов

arrayExample.pop(); // здесь сложность алгоритма  O(1) - объяснения см. предыдущий пункт

arrayExample.shift() // здесь сложность алгоритма O(n) (линейная) - посколько при удалении элемента из начала массива
// будут изменены индексы ВСЕХ элементов. То есть массив примет вид (условно) {index: 0, value: 3}, {index: 1, value: '22'}

arrayExample.unshift(1, 3, 3) // при добавлении элементов в начало массива сложность алгоритма O(n) (линейная)
// см предыдущий пункт

// как правило, можно взять за основу, что везде, где меняются индексы в массиве или происходит "проход" по массиву,
// сложность (как минимум) линейная

const newArray = arrayExample.slice(1, 3);
// Сложность алгоритма: O(k) - где k - количество выбранных элементов.
// Метод slice создает новый массив, содержащий выбранные элементы из исходного массива.

const newArray2 = arrayExample.concat([4, 5, 6]);
// Сложность алгоритма: O(m) - где m - количество элементов, которые добавляются.
// Метод concat объединяет исходный массив с другими массивами, создавая новый массив.

// Важное замечание:
// Некоторые методы, такие как map(), filter(), reduce() и т.д., также выполняют проход по массиву,
// и их сложность зависит от количества элементов и выполнения функции обратного вызова для каждого элемента.